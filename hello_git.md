![Logo](https://upload.wikimedia.org/wikipedia/commons/e/e0/Git-logo.svg )

# Работа с Git  и GitHub

* Git — распределённая система контроля версий, позволяющая сохранять изменения, внесённые в файлы, которые хранятся в репозитории. Сами изменения сохраняются в виде снимков, называемых коммитами. Они могут размещаться на разных серверах, поэтому вы всегда восстановите код в случае сбоя, а также без проблем откатитесь до любого предыдущего состояния. Кроме того, значительно облегчается взаимодействие с другими разработчиками: несколько человек могут работать над одним репозиторием одновременно, сохраняя свои изменения. 

## _Установка  Git_

* Скачиваем последнюю версию Git по ссылке https://git-scm.com/downloads

Устанавливаем с настройками по умолчанию.

 * Скачиваем последнюю версию VSCode по ссылке https://code.visualstudio.com/download

Устанавливаем.

## _Проверка правильности установки Git_
* Выполнить в терминале команду ` git --version`
При правильной и полной установки Git, укажется версия програмы.
Иначе будет указано сообщение об ошибке.

## _Настройка Git_
* Перед первым использывнием, необходимо представиться.
Для этого в терминал ввводим 2 следующие команды;
```
git config --global user.name <Ваше имя, английскими буквами>
git config --global user.email  <Ваша почта@example.com>
```
## _Начало работы_
* Создаем папку, в терминале вводим команду `git init`
это команда позволяет создать репозиторий и начать отслеживать изменения в файлах.
Создаем файл  с форматом `.md` , этот формат имеет функцию предосмотра.

_Репозиторий — это все файлы, находящиеся под контролем версий, вместе с историей их изменения и другой служебной информацией._

* Команда `git status`, позволяет получить информацию от  git, о его текущем состоянии.

_Красный цвет названия документа говорит о том что некоторые изменения могут быть сохранены, зеленый- измененный файл._

* Команда `git add`, подгатавливает изменения для дальнейшей фиксации, добавляет файлу версионность(индексация)

## _Коммиты_

* Команда `git commit ` делает для проекта сохранение текущего состояния изменений, добавленных в раздел проиндексированных файлов. Такие подтвержденные сохранения состояния можно рассматривать как «безопасные» версии проекта — Git не будет их менять, пока вы явным образом не попросите об этом.

* Команда `git commit -m "текст" ` создает для проекта сохранение с коментарием.

* Для просмотра журнала фиксаций существует команда `git log` - журнал всех коммитов с их универсальными кодами.

* Универсальный код позволяет перейти к определенному коммиту  при помощи команды `git checkout <id коммита>`  обычно достаточно 6 первых цифр.

* Команда `git log --oneline `Для просмотра журнала в одну строку.

* Команда `git log --oneline -2`, укажет 2 последних коммита.

* Для возврата в актуальное состояние команды `git master` и `git swictch`, эти команды подходят, когда мы хотим просто посмотреть версию, что то взять и вернуться в актуальную версию.

_Если в таком состояниимы сделаем коммит не создав ветки, и перейдем в актуальное состояние, в журнале изменений мы его не увидим. Он  сохранится, но для его поиска придется использывать дополнительные команды, тратить время. Поэтому git предлагает создать новую ветвь._
* Команда `git switch -c <Новое имя>` - создать новую ветвь.

 _Указатель `HEAD`, говорит  на каком гите мы находимся в данный момент._

* `git diff` - указывает изменения которые мы совершили.
* `git restore` -убирает изменения которые мы добавили.
* `git --amend -m <Текст>` - позволяет заменить коммит.

 ## Синтаксис языка MarkDown
Язык MarkDown используется для оформления Readme  файлов.

* `# Заголовок`- выделение заголовков, количествво # символов задает уровень заголовка (поддерживает 6 уровней)
* `= или -` -подчеркивание этим символом задает (не менее 3 раз подряд) выделяют заголовки первого ("=") и вторго ("-") уровней .
* `**Полуужирное начертание**` или `__Полужирное начертание__`
* `*Курсивное начертание*` или `_Курсивное начертание_`
* `***Полужирное курсивное начертание***`
* `~~Зачеркнутый текст~~`
* `* Строка` -не нумерованные списки, символ "*" в начале строки
* `1,2,3...` - нумерованные списки

Справочник по Markdown от Microsoft:
https://learn.microsoft.com/ru-ru/contribute/markdown-reference

## Добавление картинок
Добавление картинок в текст производится командой;
```
![<name>](picture_name.png)
```
Не принято добовлять фотографии или большие файлы в git, их обычно игнорируют и работаю только с текстом... Вместо изображений обычно используют ссылки с сайтов  на изображения.

## Игнорирование файлов
Для того что бы исключить из отслеживания в репозитории определенные папки или файлы, необходимо создать файл ***.gitignore*** . Когда мы создали файл необходиомо записать в его названия или шаблоны соответствущие таким файлам или папкам. Шаблонами в этом случае будет:
```
.png
.jpg
```
позволит игнорировать все файлы на конце которых будут эти 4 символа.

## Создание веток Git
Ветка - это набор commit`ов которые идут друг за другом.

 Ветвление означает, что вы отклоняетесь от основной линии разработки и продолжаете работу, не вмешиваясь в основную линию. 

 Использование веток в качестве версий и черновиков которые в итоге сольються с основной веткой.

По умолчанию имя основной ветки git это ***Master***
 * Создать git ветку можно командой:
 ```
 git branch <название ветки>
 ```
 * Команда:
 ```
 git checkout -b <name>
 ```
  после создания ветки сразу переведет вас на ее.
  * Команда позваляющая переименовать ветку :
  ```
  git branch <oldbranch> <newbranch>
  ```

## Списки веток и переключения между нимим.
  * Список веток в репозиториях можно посмотреть  с помощью команды : `git branch`
  * Параметр который позволяет видеть историю в виде дерева:`git log --graph`, а увидеть в кратком формате `git log --graph --oneline`
* Переключение между веток осуществляется командой:` git checkout <name_branch>`

  ## Слияние веток и разрешение конфликтов.
  Для слияния необходимо перейти в ветку ***Master***, так как слияние будет переходить из второстепенной ветки>в основную ветку***Master***. И уже только после этого 
   необходимо выполнить команду;
  ```
  git merge <название выбранной ветки>
  ```
  * отмена слияния выполняется командой:
  ```
  git merge --abort
  ```
Однако при слиянии ветвей могут возникать конфликты, конфликты слияния происходят при слиянии ветвей, имеющих конкурирующие фиксации, и Git требуется наша помощь, чтобы принять решение относительно того, какие изменения следует включить в окончательное слияние.

VSCode визуально  отображает 2 блока и следующие параметры  для разрешения конфликта:
* Принять текущее изменение
* Принять входящее изменение
* Принять оба изменения
* Сравнить

*Принять оба изменения* - сохраняется  входящее и текущее изменение с последующим ручным  редактированием всей информацци автором.

*Сравнить* -  открывается доп. вкладка  с подрыбным пояснением изменений 

В конечном результате мы выбираем один из этих вариантов для разрешения конфликта.
  
  **!** После разрешения конфликта выполнется commit, с пометкой о разрешении конфликта.
## Удаление веток

* Для удаления ветки в терминал ввводится команда `git branch -d <название ветки>`
При этои невозможно удалить ветку  находясь в ней. Нельзя удалить ветку не выполнив слияния. Произойдет ошибка.

* Принудительное удаление ветки, т.е. если мы уверены что хотим удалить ветку:
 `git branch -D <название ветки>`, используется оператор с `-D`.


# Работа с GitHub
 *GitHub -сервис, основан на системе контроля версий GitHub, используется для удаленной и совместной работы.*

 Для того что бы работать удаленно;
 1. Необходимо создать аккаунт на GitHub.
 2. Создать локальный репозиторий минимум с одним commit.
 
3. Так же на сайте GitHub, в разделе NewRepository- создаем новый репозиторий.
Получаем ссылку на наш  удаленный репозиторий , а также подсказки в командах:

```
git remote add origin <ссылка на удаленный репозиторий>
```
*origin*- ярлык\название
```
git branch -M main
```

 Команда которая переименовывает  основную ветку *master* в *main*
```
git push -u  origin main
```
Связывающая локальныую с удаленной веткой, добавляет в отслеживание.

*push*- толкать

Выполняем эти команды в терминале Git.


## Команды для работы:

*  Проверка удаленных репозиториев
```
git remote
```
*  Проверка удаленных репозиториев с параметром получения и отправки
```
git remote -v
```
* Команда которая создает **копию** удаленного репозитория, и переносит ее в локальный репозиторий 
 ```
 git clone
 ```
 * Переход в корневую папку (после git clone)
 ```
 cd <название папки>
 ```

 * Команда позваляющая стянуть актуальные изменения с удаленного репозитория:
 ```
 git pull
 ```
но стоит понимать что она является составной, из `git merge` (слияние) и `git fetch` (получение)
 и  git попытается сделать merge
*Команда отправляющая изменения из локального в удаленный репозиторий:
```
git push
```
Особенностями этой команды являються  то, что  git  должен знать адрес удаленного репозиториия и быть авторизован на внесение изменений в удаленный репозиторий.

## Конфликты
При выполнении команды `git pull`  возникает конфликт слияния.
VSCode отображает нам знакомые нам блоки с параметрами разрешения конфликта.
* Принять текущее изменение
* Принять входящее изменение
* Принять оба изменения
* Сравнить

В конечном результате мы выбираем один из этих вариантов для разрешения конфликта.
* **!** После разрешения конфликта выполнется commit, с пометкой о разрешении конфликта.
* **!** Обозначение удаленной ветки в commit -`origin/Main`

## PullRequest
*-запрос на вливание моих изменений в чужой репозиторий*

1. Делаем Fork (Вилка) от репозитория Автора на GitHub, после чего у нас на GitHub в разделе репозиториев появляется копия этого репозитория
2. Копируем адрес уже нашего репозитория GitHub.
3. В терминале локального репозитория даем команду `git clone <ссылка репозитория>`
4. Переходим в корневую папку через команду `cd <название папки>`
5. !Все изменения которые мы хотим предложить должны выполнятся в новой ветке. выполняем команду `git checkout -b <name_branch>`
6. Также создаем дополнительный файл README.md, создаем коммит с информацией.
7. Перед отправкой Push  на свой удаленный репозиторий выполняется команда: `git push --set -upstream origin <name_branch>`, в этом случае мы добавляем к отслеживанию нашу новую ветку.
8. Выполняется `git push` (на удаленном репозитории появится наша новая ветка)
9.  А теперь непосредственно сам PullRequest. Выбираем нашу ветку, добавляем коментарий и пояснение к предложению. И далее отправка PullRequest...
10. Ожидаем ответа :)

*Со стороны принмающего будут доп. команды позваляющие проверить предложение локально или непосредственно на самом GitHub* 